---
# Validate required variables
- name: Check if xiraid_arrays is defined
  ansible.builtin.fail:
    msg: |
      xiraid_arrays is not defined!

      If using automatic detection (nvme_auto_namespace: true):
        - Ensure nvme_namespace role runs before raid_fs
        - Check that NVMe data drives were detected
        - Review nvme_namespace role output for errors

      If using manual configuration:
        - Define xiraid_arrays in your preset (e.g., presets/default/raid_fs.yml)
        - Set nvme_auto_namespace: false
  when: xiraid_arrays is not defined or xiraid_arrays | length == 0

- name: Check if xfs_filesystems is defined
  ansible.builtin.fail:
    msg: |
      xfs_filesystems is not defined!

      If using automatic detection (nvme_auto_namespace: true):
        - Ensure nvme_namespace role runs before raid_fs

      If using manual configuration:
        - Define xfs_filesystems in your preset
  when: xfs_filesystems is not defined or xfs_filesystems | length == 0

- name: Apply xiRAID license
  ansible.builtin.command: "xicli license update -p {{ xiraid_license_path }}"
  changed_when: false
  tags: [raid_fs, raid]

- name: Build list of xiRAID device paths
  ansible.builtin.set_fact:
    xiraid_device_paths: >-
      {{
        ((xiraid_arrays | map(attribute='devices') | flatten | list) +
        (xiraid_spare_pools | default([]) | map(attribute='devices') | flatten | list))
        | unique | list
      }}
  tags: [raid_fs, raid]

- name: Build list of xiRAID device basenames
  ansible.builtin.set_fact:
    xiraid_device_basenames: "{{ xiraid_device_paths | map('basename') | list }}"
  tags: [raid_fs, raid]

- name: Clean xiRAID drives
  ansible.builtin.command: "xicli drive clean -d {{ item }}"
  loop: "{{ xiraid_device_paths }}"
  register: drive_clean_result
  changed_when: false
  failed_when: false
  tags: [raid_fs, raid, cleanup]

- name: Warn about drives that could not be cleaned
  ansible.builtin.debug:
    msg: "WARNING: Could not clean {{ item.item }}: {{ item.stderr | default('unknown error') }}"
  loop: "{{ drive_clean_result.results }}"
  when:
    - item.rc is defined
    - item.rc != 0
  loop_control:
    label: "{{ item.item }}"
  tags: [raid_fs, raid, cleanup]

- name: Ensure mdadm package present
  ansible.builtin.apt:
    name: mdadm
    state: present
  tags: [raid_fs, raid]

- name: Gather existing spare pools
  ansible.builtin.command: xicli pool show -f json
  register: xiraid_pools
  changed_when: false
  failed_when: xiraid_pools.rc != 0
  tags: [raid_fs, raid]

- name: Set fact – parsed pools
  ansible.builtin.set_fact:
    _raw_pools: "{{ xiraid_pools.stdout | from_json }}"
  tags: [raid_fs, raid]

- name: Set fact – existing pool names
  ansible.builtin.set_fact:
    existing_pool_names: >-
      {%- set parsed = _raw_pools | default({}, true) -%}
      {%- if parsed is mapping -%}
        {{ parsed.keys() | list }}
      {%- elif parsed is iterable and parsed is not string -%}
        {{ parsed | map(attribute='name') | list }}
      {%- else -%}
        []
      {%- endif -%}
  tags: [raid_fs, raid]

- name: Create xiRAID spare pools
  ansible.builtin.command: >-
    xicli pool create -n {{ item.name }} -d {{ item.devices | join(' ') }}
  register: pool_create
  changed_when: pool_create.rc == 0
  failed_when:
    - pool_create.rc != 0
    - pool_create.stderr is not search('already exists')
  loop: "{{ xiraid_spare_pools | default([]) }}"
  loop_control:
    loop_var: item
  when:
    - xiraid_spare_pools is defined
    - xiraid_spare_pools | length > 0
    - item.name not in existing_pool_names
  tags: [raid_fs, raid]

- name: Find active MD RAID arrays
  ansible.builtin.command: lsblk -ln -o NAME,TYPE | awk '$2 ~ /^raid/ {print "/dev/"$1}'
  register: mdraid_scan
  changed_when: false
  failed_when: false
  tags: [raid_fs, raid]

- name: Stop leftover MD RAID arrays on xiRAID devices
  ansible.builtin.shell: |
    set -e
    md_devs=$(lsblk -ln -o NAME,TYPE | awk '$2 ~ /^raid/ {print "/dev/"$1}')
    for md in $md_devs; do
      [ -n "$(lsblk -nro MOUNTPOINT "$md")" ] && continue
      comps=$(ls -1 /sys/block/$(basename "$md")/slaves)
      stop_md=0
      for c in $comps; do
        case " {{ xiraid_device_basenames | join(' ') }} " in
          *" $c "*)
            stop_md=1
            ;;
        esac
      done
      if [ "$stop_md" = 1 ]; then
        mdadm --stop "$md"
      fi
      for c in $comps; do
        case " {{ xiraid_device_basenames | join(' ') }} " in
          *" $c "*)
            mdadm --zero-superblock "/dev/$c"
            ;;
        esac
      done
    done
  args:
    executable: /bin/bash
  changed_when: false
  tags: [raid_fs, raid]

- name: Gather existing xiRAID arrays (json)
  ansible.builtin.command: xicli raid show -f json
  register: xiraid_list
  changed_when: false
  failed_when: xiraid_list.rc != 0
  tags: [raid_fs, raid]

- name: Set fact – parsed arrays
  ansible.builtin.set_fact:
    _raw_arrays: "{{ xiraid_list.stdout | from_json }}"
  tags: [raid_fs, raid]

# xicli returns either a list of dicts or a dict keyed by array name.
# Normalise to a flat list of array name strings for the skip check.
- name: Set fact – existing array names
  ansible.builtin.set_fact:
    existing_array_names: >-
      {%- set parsed = _raw_arrays | default({}, true) -%}
      {%- if parsed is mapping -%}
        {{ parsed.keys() | list }}
      {%- elif parsed is iterable and parsed is not string -%}
        {{ parsed | map(attribute='name') | list }}
      {%- else -%}
        []
      {%- endif -%}
  tags: [raid_fs, raid]

- name: Create xiRAID arrays that are missing
  ansible.builtin.include_tasks: create_array.yml
  loop: "{{ xiraid_arrays }}"
  loop_control:
    loop_var: item
  when: item.name not in existing_array_names
  tags: [raid_fs, raid]

- name: Attach spare pools to existing arrays
  ansible.builtin.command: >-
    xicli raid modify --name {{ item.name }} -sp {{ item.spare_pool }}
  register: raid_mod
  changed_when: raid_mod.rc == 0
  failed_when:
    - raid_mod.rc != 0
    - raid_mod.stderr is not search('already')
  loop: "{{ xiraid_arrays }}"
  loop_control:
    loop_var: item
  when: item.spare_pool is defined
  tags: [raid_fs, raid]

# ----------------------- Filesystem section -------------------
- name: Ensure XFS utils present
  ansible.builtin.apt:
    name: xfsprogs
    state: present
  tags: [raid_fs, fs]

- name: Create XFS filesystems if absent
  ansible.builtin.include_tasks: create_fs.yml
  loop: "{{ xfs_filesystems }}"
  loop_control:
    loop_var: item
  tags: [raid_fs, fs]
