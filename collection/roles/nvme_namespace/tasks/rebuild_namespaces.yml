---
# Rebuild NVMe namespaces on data drives
# Creates: n1 = small namespace (500MB), n2 = large namespace (remaining capacity)

# Initialize tracking variables
- name: Initialize failed devices list
  ansible.builtin.set_fact:
    nvme_failed_devices: []

# Delete existing namespaces on each data drive
- name: Delete existing namespaces
  ansible.builtin.shell: |
    set -e
    controller="{{ item.controller }}"
    failed=0

    # Get controller ID for detach
    cntlid=$(nvme id-ctrl "$controller" 2>/dev/null | awk '/cntlid/{print $3}')
    cntlid=${cntlid:-0}
    # Remove 0x prefix if present
    cntlid=$(echo "$cntlid" | sed 's/^0x//')
    # Convert hex to decimal
    cntlid=$((16#$cntlid))

    # Get list of existing namespace IDs (use -a to include unattached namespaces)
    # Output format is "[   0]:0x1" - extract hex NSID after colon and convert to decimal
    ns_list=$(nvme list-ns "$controller" -a 2>/dev/null | awk -F: '{gsub(/^0x/,"",$2); if($2 ~ /^[0-9a-fA-F]+$/) printf "%d\n", strtonum("0x"$2)}' || true)

    for nsid in $ns_list; do
      echo "Detaching and deleting namespace $nsid on $controller (cntlid=$cntlid)"
      # Detach using actual controller ID
      nvme detach-ns "$controller" -n "$nsid" -c "$cntlid" 2>/dev/null || true
      # Delete the namespace
      if ! nvme delete-ns "$controller" -n "$nsid" 2>&1; then
        echo "Warning: Failed to delete namespace $nsid on $controller"
        failed=1
      fi
    done

    exit $failed
  args:
    executable: /bin/bash
  register: ns_delete_result
  loop: "{{ nvme_topology }}"
  changed_when: ns_delete_result.rc == 0
  failed_when: false

# Track failed deletions
- name: Track failed namespace deletions
  ansible.builtin.set_fact:
    nvme_failed_devices: "{{ nvme_failed_devices + [item.item.controller] }}"
  loop: "{{ ns_delete_result.results }}"
  when:
    - item.rc != 0
    - not nvme_skip_failed_devices | bool

- name: Fail on namespace deletion errors
  ansible.builtin.fail:
    msg: "Failed to delete namespaces on: {{ nvme_failed_devices | join(', ') }}"
  when:
    - nvme_failed_devices | length > 0
    - not nvme_skip_failed_devices | bool

# Create small namespace (500MB) on each drive
- name: Create small namespace ({{ nvme_small_ns_size_mb }}MB)
  ansible.builtin.shell: |
    set -e
    controller="{{ item.controller }}"
    block_size="{{ nvme_namespace_block_size }}"
    size_mb="{{ nvme_small_ns_size_mb }}"
    shared="{{ nvme_namespace_shared | bool | lower }}"

    # Calculate block count using configured block size
    blocks=$(( size_mb * 1024 * 1024 / block_size ))

    # Determine LBA format index for desired block size
    # Parse available formats and find matching lbads
    target_lbads=9  # default 512 bytes (2^9)
    case "$block_size" in
      4096) target_lbads=12 ;;  # 2^12 = 4096
      512)  target_lbads=9 ;;   # 2^9 = 512
    esac

    # Find flbas index with matching lbads (no metadata)
    flbas=$(nvme id-ns "$controller" -n 0xffffffff 2>/dev/null | \
            grep -E "^lbaf\s+[0-9]+" | \
            grep "ms:0" | \
            grep "lbads:${target_lbads}" | \
            head -1 | \
            awk '{print $2}' | tr -d ':')

    if [ -z "$flbas" ]; then
      echo "Warning: Could not find LBA format for ${block_size} bytes, using format 0"
      flbas=0
    fi

    # Build nmic flag for shared namespace
    nmic_flag=""
    if [ "$shared" = "true" ]; then
      nmic_flag="-m 1"
    fi

    echo "Creating small namespace on $controller: $blocks blocks (${size_mb}MB, BS=${block_size}, flbas=${flbas}, shared=${shared})"

    # Create namespace with size and capacity equal
    nvme create-ns "$controller" -s "$blocks" -c "$blocks" -f "$flbas" -d 0 $nmic_flag

    # Get the new namespace ID (should be 1) - use -a to see unattached namespaces
    # Output format is "[   0]:0x1" - extract hex NSID and convert to decimal
    nsid=$(nvme list-ns "$controller" -a 2>/dev/null | tail -1 | awk -F: '{gsub(/^0x/,"",$2); printf "%d", strtonum("0x"$2)}')

    if [ -z "$nsid" ]; then
      echo "Error: Failed to get namespace ID after creation"
      exit 1
    fi

    # Get controller ID for attach
    cntlid=$(nvme id-ctrl "$controller" 2>/dev/null | awk '/cntlid/{print $3}')
    cntlid=${cntlid:-0}

    echo "Attaching namespace $nsid to controller (cntlid=$cntlid)"
    nvme attach-ns "$controller" -n "$nsid" -c "$cntlid"

    echo "Successfully created small namespace: ${controller}n${nsid}"
  args:
    executable: /bin/bash
  register: small_ns_result
  loop: "{{ nvme_topology }}"
  when: item.controller not in nvme_failed_devices
  changed_when: small_ns_result.rc == 0
  failed_when: false

# Track failed small namespace creations
- name: Track failed small namespace creations
  ansible.builtin.set_fact:
    nvme_failed_devices: "{{ nvme_failed_devices + [item.item.controller] }}"
  loop: "{{ small_ns_result.results }}"
  when:
    - item.skipped is not defined or not item.skipped
    - item.rc is defined and item.rc != 0

# Create large namespace (remaining capacity) on each drive
- name: Create large namespace (remaining capacity)
  ansible.builtin.shell: |
    set -e
    controller="{{ item.controller }}"
    block_size="{{ nvme_namespace_block_size }}"
    shared="{{ nvme_namespace_shared | bool | lower }}"

    # Get unallocated capacity
    unalloc=$(nvme id-ctrl "$controller" 2>/dev/null | grep -E '^\s*unvmcap\s*:' | awk -F: '{print $2}' | tr -d ' ')

    if [ -z "$unalloc" ] || [ "$unalloc" = "0" ]; then
      # Calculate from total capacity minus allocated
      total_cap=$(nvme id-ctrl "$controller" 2>/dev/null | grep -E '^\s*tnvmcap\s*:' | awk -F: '{print $2}' | tr -d ' ')
      # Get size of existing namespaces
      alloc=0
      for ns in $(nvme list-ns "$controller" -a 2>/dev/null | awk -F: '{gsub(/^0x/,"",$2); if($2 ~ /^[0-9a-fA-F]+$/) printf "%d\n", strtonum("0x"$2)}'); do
        ns_size=$(nvme id-ns "${controller}n${ns}" 2>/dev/null | grep -E '^\s*nsze\s*:' | awk -F: '{print $2}' | tr -d ' ')
        alloc=$((alloc + ns_size * block_size))
      done
      unalloc=$((total_cap - alloc))
    fi

    if [ "$unalloc" -le 1048576 ]; then
      echo "Warning: Insufficient unallocated capacity ($unalloc bytes) on $controller"
      exit 0
    fi

    # Determine LBA format index for desired block size
    target_lbads=9  # default 512 bytes (2^9)
    case "$block_size" in
      4096) target_lbads=12 ;;  # 2^12 = 4096
      512)  target_lbads=9 ;;   # 2^9 = 512
    esac

    # Find flbas index with matching lbads (no metadata)
    flbas=$(nvme id-ns "$controller" -n 0xffffffff 2>/dev/null | \
            grep -E "^lbaf\s+[0-9]+" | \
            grep "ms:0" | \
            grep "lbads:${target_lbads}" | \
            head -1 | \
            awk '{print $2}' | tr -d ':')

    if [ -z "$flbas" ]; then
      echo "Warning: Could not find LBA format for ${block_size} bytes, using format 0"
      flbas=0
    fi

    # Build nmic flag for shared namespace
    nmic_flag=""
    if [ "$shared" = "true" ]; then
      nmic_flag="-m 1"
    fi

    # Leave 1MB buffer, calculate blocks
    blocks=$(( (unalloc - 1048576) / block_size ))

    echo "Creating large namespace on $controller: $blocks blocks ($(( blocks * block_size / 1000000000 ))GB, BS=${block_size}, flbas=${flbas}, shared=${shared})"

    # Create namespace
    nvme create-ns "$controller" -s "$blocks" -c "$blocks" -f "$flbas" -d 0 $nmic_flag

    # Get the new namespace ID (should be 2) - use -a to see unattached namespaces
    # Output format is "[   0]:0x1" - extract hex NSID and convert to decimal
    nsid=$(nvme list-ns "$controller" -a 2>/dev/null | tail -1 | awk -F: '{gsub(/^0x/,"",$2); printf "%d", strtonum("0x"$2)}')

    if [ -z "$nsid" ]; then
      echo "Error: Failed to get namespace ID after creation"
      exit 1
    fi

    # Get controller ID for attach
    cntlid=$(nvme id-ctrl "$controller" 2>/dev/null | awk '/cntlid/{print $3}')
    cntlid=${cntlid:-0}

    echo "Attaching namespace $nsid to controller (cntlid=$cntlid)"
    nvme attach-ns "$controller" -n "$nsid" -c "$cntlid"

    echo "Successfully created large namespace: ${controller}n${nsid}"
  args:
    executable: /bin/bash
  register: large_ns_result
  loop: "{{ nvme_topology }}"
  when: item.controller not in nvme_failed_devices
  changed_when: large_ns_result.rc == 0
  failed_when: false

# Track failed large namespace creations
- name: Track failed large namespace creations
  ansible.builtin.set_fact:
    nvme_failed_devices: "{{ nvme_failed_devices + [item.item.controller] }}"
  loop: "{{ large_ns_result.results }}"
  when:
    - item.skipped is not defined or not item.skipped
    - item.rc is defined and item.rc != 0

# Rescan NVMe subsystem to detect new namespaces
- name: Rescan NVMe controllers
  ansible.builtin.shell: |
    # Try nvme reset first, fall back to echo 1 to rescan
    nvme reset {{ item.controller }} 2>/dev/null || \
      echo 1 > /sys/class/nvme/{{ item.controller | basename }}/rescan 2>/dev/null || \
      true
  loop: "{{ nvme_topology }}"
  when: item.controller not in nvme_failed_devices
  changed_when: false
  failed_when: false

# Wait for namespace devices to appear
- name: Wait for small namespace devices (n1) to appear
  ansible.builtin.wait_for:
    path: "/dev/{{ item.controller | basename }}n1"
    timeout: 30
  loop: "{{ nvme_topology }}"
  when: item.controller not in nvme_failed_devices
  ignore_errors: "{{ nvme_skip_failed_devices }}"

- name: Wait for large namespace devices (n2) to appear
  ansible.builtin.wait_for:
    path: "/dev/{{ item.controller | basename }}n2"
    timeout: 30
  loop: "{{ nvme_topology }}"
  when: item.controller not in nvme_failed_devices
  ignore_errors: "{{ nvme_skip_failed_devices }}"

# Collect final namespace list
- name: List created small namespaces (n1)
  ansible.builtin.shell: |
    ls -1 /dev/{{ item.controller | basename }}n1 2>/dev/null || true
  register: small_ns_devices
  loop: "{{ nvme_topology }}"
  when: item.controller not in nvme_failed_devices
  changed_when: false

- name: List created large namespaces (n2)
  ansible.builtin.shell: |
    ls -1 /dev/{{ item.controller | basename }}n2 2>/dev/null || true
  register: large_ns_devices
  loop: "{{ nvme_topology }}"
  when: item.controller not in nvme_failed_devices
  changed_when: false

# Build device lists for RAID configuration
- name: Build small namespace device list
  ansible.builtin.set_fact:
    nvme_small_ns_devices: >-
      {{ small_ns_devices.results
         | selectattr('stdout', 'defined')
         | selectattr('stdout', 'match', '^/dev/')
         | map(attribute='stdout')
         | list }}

- name: Build large namespace device list
  ansible.builtin.set_fact:
    nvme_large_ns_devices: >-
      {{ large_ns_devices.results
         | selectattr('stdout', 'defined')
         | selectattr('stdout', 'match', '^/dev/')
         | map(attribute='stdout')
         | list }}

- name: Display namespace rebuild results
  ansible.builtin.debug:
    msg: |
      ========== Namespace Rebuild Results ==========
      Small namespaces (n1) created: {{ nvme_small_ns_devices | length }}
        {{ nvme_small_ns_devices | join('\n        ') | default('none') }}

      Large namespaces (n2) created: {{ nvme_large_ns_devices | length }}
        {{ nvme_large_ns_devices | join('\n        ') | default('none') }}

      Failed devices: {{ nvme_failed_devices | join(', ') | default('none') }}
      ===============================================
